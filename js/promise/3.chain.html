<script>
    //then的链式调用
    const PENDING = Symbol('PENGDING');
    const FULFILLED = Symbol('FULFILLED');
    const REJECTED = Symbol('REJECTED');
    function MyPromise(fn) {
      this.value = undefined;
      this.onFulfilled = [];
      this.status = PENDING;
      let self = this;
      function resolve(value) {
        self.value = value;
        self.status = FULFILLED;
        console.log(value);
        //调用 onFulfilled 枚举
        self.onFulfilled.forEach(fn => {
          fn(value);
        });
      }
      function reject() {}
      fn(resolve, reject);
    }

    MyPromise.prototype.then = function(onFulfilled, onRejected) {
      if (this.status === FULFILLED) {
        onFulfilled(this.value);
      }
      else if (this.status === PENDING) 
      {
          //每个then 都返回promise 支持链式调用
          return new MyPromise((resolve, reject) => {
                //resolve()
                this.onFulfilled.push((value) => {
                    //then的回调 需要知道返回值
                    let x = onFulfilled(value);
                    //当前这个 promise 需要resolvevalue 下一个then 才会被调用
                    if(x instanceof MyPromise) {
                        x.then(resolve, reject)
                    }
                    // resolve();
                })
          })
        // this.onFulfilled.push(onFulfilled);
      } 
      else {}
    //   return this;
    }

    new MyPromise((resolve, reject) => {
      setTimeout(() => {
        resolve(1);
      }, 2000);
    })
    .then((res) => {
      console.log(res); //1
      return new MyPromise((resolve, reject) => {
            setTimeout(() => {
                resolve(2);
            }, 2000);
        })
    }, () => {})
    //上一个then返回一个promise成功了 才会给 下一个then
    .then((res) => {
        console.log(res); 
    })
  </script>