## 浅克隆
    浅克隆之所以被称为浅克隆，是因为对象只会被克隆最外部的一层,
    至于更深层的对象,则依然是通过引用指向同一块堆内存.

## 深克隆
- 简单版
    JSON.parse方法可以将JSON字符串反序列化成JS对象，
    stringify方法可以将JS对象序列化成JSON字符串,
    这两个方法结合起来就能产生一个便捷的深克隆.
```js
    const newObj = JSON.parse(JSON.stringify(oldObj));
 ```
- 局限性：
1. 他无法实现对函数 、RegExp等特殊对象的克隆
2. 会抛弃对象的constructor,所有的构造函数会指向Object
3. 对象有循环引用,会报错

- 面试版深克隆
由于要面对不同的对象(正则、数组、Date等)要采用不同的处理方式，我们需要实现一个对象类型判断函数。

- 局限性:
1. 一些特殊情况没有处理: 例如Buffer对象、Promise、Set、Map
2. 另外对于确保没有循环引用的对象，我们可以省去对循环引用的特殊处理，因为这很消耗时间

- 实现一个深克隆函数
1. 判断对象类型的函数  isType
    面对不同的对象(正则、数组、Date等)要采用不同的处理方式
2. 提取flags的函数  getRegExp 处理正则表达式
3. 实现深克隆
思路：
1. 递归
2. 判断类型
3. 检查环(也叫循环引用)
4. 需要忽略原型

    - 判断类型
    - 处理正则
    - 维护两个储存循环引用的数组
        - 对数组做特殊处理
        - 对正则对象做特殊处理
        - 对Date对象做特殊处理
        - 处理对象原型
        - 处理循环引用